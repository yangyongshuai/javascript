### `JavaScript`组成部分
* `ECMAScript` (European Computer Manufacturers Association Scrip) 简称ES这部分包含整个所有js语言的底层及语法
* `DOM` (document object model)文档对象模型
* `BOM` (browser object model)浏览器对象模型

### `javascript`讲解
* `js`做为弱类型解释型脚本型语言，在运行每行代码时，浏览器里专门解析js的v8解析引擎就开始逐行对代码先进行预编译预解析，作用就是检查每行代码的语法是否使用正确，解析一些需要进驻内存的变量数据或对象数据。

# `ECMAScript:`部分

### `JavaScript`声明变量 
* `var` (variable)
* `let`
* `const`

### 注意：
* 面试题：`var`,`let`,`const`  区别
	- `var`声明的变量会挂载在`window`上，而`let`和`const`声明的变量不会
	- `var`声明变量存在变量提升，`let`和`const`不存在变量提升
	- `let`和`const`声明形成块作用域
	- 同一作用域下`let`和`const`不能声明同名变量，而`var`可以
	- `const:` 
		- 一旦声明必须赋值,不能使用`null`占位。
		- 声明后不能再修改
		- 如果声明的是复合类型数据，可以修改其属性
* 变量名命名
	- 不能数字开头
	- 可以有`$`符号或者`_`符号
	- 不能用关键词和系统保留字

### 基本数据类型 （值类型） 
1. `Number` 	数字类型
2. `String`		字符串类型 	`('单引号',"双引号",反引号(ES6))`
3. `Boolean` 	布尔类型		`(false(假),true(真))`
4. `Null`		空值类型
5. `Undefined`	未定义类型
6. `Symbol`		(ES6,唯一的保证不会与其他属性名产生冲突。)

### 模板字符串好处
	- 可以换行
	- 可以在字符串中使用变量
### 复合数据类型  （引用类型）
1. `Object`		对象类型
2. `Arrey`
3. `Function`
4. `Math`
......

### 注意：
* 面试题：`Null`和`Undefined`的区别
	- Null会占用内存空间,相当于内存里为null开辟一个专门存它的空间
	- Undefined 是未定义的,未定义的意思就是不存在,更别提内存空间了
* 面试题：值类型和引用类型区别
	- 值类型变量赋值时,其实只是将值给对方,两个变量依然在操作两个不同内存地址的数据
	- 引用变量赋值时,其实就是两个变量指向了同一个内存地址的值
* 深拷贝和浅拷贝:
	- 基本数据类型

### 附加：
* 用`java`思想（堆类型和栈类型）来理解值类型和引用类型 
	- 栈类型空间里主要储存一种叫值类型的变量,值类型变量在赋值时,是将自己的值copy一份赋值给对方的,结果就是不管修改那个值类型变量的值时,都不会影响到对方,其本质原理就是两个值类型变量的内存地址不同,值类型变量在赋值时,仅仅只是把值copy一份赋值给对方的操作 
	- 堆内存空间里主要存储的是引用类型变量,那么引用类型的变量在赋值操作时,不仅仅将自己的值给到对方,并且将自己的内存地址也一起给了对方

### 查看数据类型
* `typeof` 判断数据类型
* `Object.prototype.toString.call()` 查看真实类型

### 数据类型转换
* 隐式类型转换 （自动类型转换）
* 强制类型转换 （显式类型转换）
	- Number() 转数字
	- parseInt() 转整数
	- parseFloat() 转小数
	- String/toString/ ''   转字符串

### 运算符
1. 赋值运算符  		`=, +=, -=, /=, %=`
2. 算数运算符  		`+, -, *, /, %, ++, --,` 
3. 关系(比较)运算符  	`==, ===, !=, !==, >, <, >=, <=`
4. 三元(目)表达式   	`? :`
5. 逻辑运算符			`&&(短路与), ||(短路或), !(非)`
6. 位运算符			`&(按位与), |(按位或), ~(按位取反)`

### 注意：
	* 运算符优先级  
		- 小括号 -> ++算数运算符 -> 逻辑运算符! -> 算术运算符 -> 关系运算符 -> 逻辑运算符&& -> 逻辑运算符 || -> 赋值运算符 -> 算数运算符++
	* `boolean` 类型的数据隐式转换方式:
		- `Number:` 非0为真，0为假
		- `String:` 非空为真，真为假
		- `null`和`undefined`都是假
	* 短路语法的隐式转换
		- `&&`  左为真,值为右,左为假,值为左
		- `||`	左为假,值为右,左为真,值为左

### 弹窗三大佬 （属于BOM部分）
* `alert`
* `confirm`  询问式弹窗，返回布尔值
* `prompt`	

### 什么是语法糖（syntax sugar）
* 解决实际编程时过于复杂的一些语法,将语法在底层就进行简化操作的封装,这样程序猿就不在需要用一些复杂的语法方式来进行编程,而是用相应的语法糖语法来编程

### 循环判断语句
1. `if` 语法
	- if
	- else-if : 可以有多个
	- else : 可以省略不写
2. `switch`语法
	- case
	- break 终止switch运行
	- default 可以省略不写
3. `while` 循环 `(Boolean)`
4. `do while`循环
5. `for`循环
	- 普通for循环 （循环索引;循环条件 ;更新循环索引） 循环数组
	- for in 循环  循环JSON对象
	- for of 循环  循环数组

### 嵌套循环
* 外侧循环一次,内层循环一轮
* 缺点：
	- 对程序性能极高损耗浪费

### 注意：
* `if` 和 `switch` 的使用：
	- `if-else` 可以判断区间范围的条件,所以区间范围的条件,建议首选`if-else`
	- `switch` 单个值条件判断,建议`seitch`判断
* 循环三要素：
	- 循环变量:定义循环次数开始时的初始值
	- 循环条件:约束循环的执行范围
	- 循环索引的更新:在执行循环体时,不断的修改循环索引,以满足对循环条件的判断需求
* `break`和`continue`的区别
	- `break`结束离他最近的循环
	- `break`:只能在循环语法或`switch`选择判断中使用,终止循环或者switch语法
	- `continue`: 只能在循环语法中使用,作用是终止当前循环,继续下一次循环
* `while`和`do while`区别:
	- `while:`   	先判断 再执行   条件不成立   循环体 一遍都不执行   
	- `do...while:` 先执行 再判断  条件不成立  循环体 至少执行一遍
### 数组创建：
```js
	//第一种方式
	var arr = new Array()
	//第二种方式
	var arr = []
```
### 数组的`length`
	- 可以动态获取数组长度
	- 长度从1开始
	- `length`可读可写
### 数组的下标(索引)
	- 从0开始

### 注意：
* 面试题冒泡排序：
```js
	//数组里各个位置的值和其余的值比大小从最小值开始依次往后到最大值的操作方式来做
	 var count1 = 0;
	 for (var i = 0; i < arr1.length; i++) {
		for (var j = i + 1; j < arr1.length; j++) {
			if (arr1[i] > arr1[j]) {
				count1++;
				var temp = arr1[i];
				arr1[i] = arr1[j];
				arr1[j] = temp;
			}
		}
	}
	//相邻两个数据进行比较，优先找最大值，这样从大到小以排序
	 var count2 = 0;
	 for (var i = 0; i < arr2.length; i++) {
		for (var j = 0; j < arr2.length - 1 - i; j++) {
			if (arr2[j] > arr2[j + 1]) {
				count2++;
				var temp = arr2[j];
				arr2[j] = arr2[j + 1];
				arr2[j + 1] = temp;
			}
		}
	}
```

### 函数创建
```js
	 // 第一种 普通定义式
	    function func1(){
	        console.log('我是函数的第一种声明方式')
	    }
	    func1('调用')
	    //  第二种 委托式 
	    var func2 = function(){
	        console.log('我是函数的第二种声明方式')
	    }
	    func2('调用')
	    // 第三种 函数构造式 函数体代码是用字符串表达的 
	    var func3 = new Function('console.log("我是函数的第三种声明方式")')
	    func3('调用')
	    // 第四种 箭头函数或lambda表达式
	    var funnc4 = () => {	
	        console.log('我是函数的第四种的声明方式')
	    }
	    func4('调用')
	    // 第五种 匿名函数 在做面向对象闭包封装开发时,可以利用函数的局部作用域,来用			匿名函数保护对
		 (function(){
		        console.log('我是匿名函数');
		  })('调用');
```

### 注意：
* 函数普通声明和委托式的区别
	- 普通声明浏览器开始运行script标签里的js代码时，会先对整个代码进行一次预编译预解析，先把代码先过一遍，找代码里是否存在"function 函数名(){}"，如果存在，则将function(){}函数直接先预解析到浏览器内存中
	- 委托式声明是将function赋值给一个变量，当运行到这个function变量时，才开始运行赋值运算符右边的function，那么这个function进入内存的时间就慢了很

### 函数三要素：
1. `arguments`用法：
	- 接收函数实参（伪数组） 伪数组不能用真数组的一些api方法可以被Array.from()转换成数组
	- `arguments callee()`使用递归时,函数调用自己
2. `return` 函数内部是一个局部作用域,要将函数里的一个数据返回出来给外边用,就必须要用return将值从函数里返回出来
3. `this`
* `this`指向
	- 对象中`this`表示当前对象
	- 主程序`this`表示`window`
	- 定时器`this`指向`window`
	- `this`在函数中
		1. `this`在哪个函数声明
		2. 这个函数的调用的函数在哪里
		3. 函数的前面有没有对象的名字,有就是它,没有就是`window`
	- 特殊情况:
		1. `call`和`apply`(`this`指向第一个参数)
		2. 箭头函数(内部`this`指向箭头函数所在作用域内的`this`)(里面的`this`指向外面的`this`)
		3. `new`(`this`指向实例)
		4. `bind`返回的函数在调用时`this`永远指向`bind`的第一个参数
* 主动改变`this`指向
	- `call`方法第一个参数是要绑定给this的值，后面传入的是一个参数列表。当第一个参数为null、undefined的时候，默认指向window。
	- `apply` 接受两个参数，第一个参数是要绑定给this的值，第二个参数是一个参数数组。当第一个参数为null、undefined的时候，默认指向window。
	- `bind` 第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用。	

### 注意：
* 面试题：
	* 什么样的集合可以被Array.from()转换成数组?
		- 伪数组类型都可以被Array.from()方法调用并转换成真数组类型
	* 什么样的可以用length属性,可以被for循环?可以使用索引呢?
		- 所有在底层继承了iterator(迭代器类型)的数据都有for循环,都有length和索引的操作.
	* `apply`和`call`和`bind`的区别:
		* 相同点:
			1. 都是用来改变函数的this对象的指向的。
			2. 第一个参数都是this要指向的对象。
			3. 都可以利用后续参数传参。
		* 不同点:
			1. call接收的是参数列表, 修改this指向,直接调用
			2. apply接收是一个数组	, 修改this指向,直接调用
			3. bian 接收的是参数列表, 返回一个新函数
* `ES6`新语法 可变参(...扩展运算符) 
	- 可变参数必须放在参数列表的最后位置

### 函数作用域链
* 当函数嵌套运行时,最内层函数要使用变量,可以使用上一层函数里的变量如果内层函数的变量在上一层函数中找不到时,则会继续找上上一层,最终找到全局环境是否有无此变量,

### 闭包  闭包：即重用一个变量，又保护变量不被污染的一种机制
* 函数内部的局部变量在函数执行完后,应该是触发浏览器的垃圾回收机制会被内存回收，如果在函数内部又来了一个局部作用域的函数,并且此内层函数使用外层函数的局部变量,导致外层函数里这个变量不能被内存回收，,因此外层函数里的这个不能被内存回收的变量就是一个闭包环境变量,这就是'真·闭包原理'
* 全局变量: 
        -  优: 可重用, 缺: 易被污染。

* 局部变量: 
        -  优: 仅函数内可用，不会被污染。 缺: 不可重用!

* 闭包缺点：
	-  闭包使用过多,会产生性能问题,会导致有过多的变量无法被回收,最终导致内容溢出!
	-  闭包会浪费内存,需要根据代码结构来合理的释放掉一部分的闭包变量所占的内存,但闭包很难完全释放
* 解决缺点：
	- 用`try-catch-finally` 释放闭包
* 触发闭包的条件:
	- 函数内有另一个子函数
	- 子函数使用了父函数内声明的至少一个变量
	- 任意时间地方都可以调用子函数

### 回调函数`callback`简称(cb)
*  将函数作为一个参数传递到另一个函数中去按需执行的过程.

### 递归
* 函数自己调用自己 
* 终止递归的条件就是if-else

### 递归执行原理：
* 递归在执行时,从外边第一次方法的调用开始执行,这时如果在执行过程中又碰见要调用自己的时候,则导致上一次调用未执行完,然后根据条件判断不断调用自己执行时,当某一次彻底执行完后,则会沿着调用自己的路线反着往回把未执行完的其他自己全部执行完就ok了

### 函数柯里化
*  是在函数内部,返回又是一个函数,这样就形成了函数调用时通过多次的小括号调用来获取最终要执行的函数
```js
	 function func2() {
		var num = 123;
		return function () {
			var newNum = num;
			return newNum;
		}
	}
	var newNum = func2()();
	console.log(newNum);
```

### 对象创建
```js
	//
	var obj = new Object()
	//
	var obj = {
		"key":"value"  //键和值
	}
```

### 原型链
- 函数有prototype,对象有_proto_,对象的_proto_指向了函数的prototype对象与对象之间的继承则是子对象函数模型的prototype指向了父对象的_proto_,最终此链一直向上指向了Object,如果Object再往上指就什么都没有了,就是所谓的null

 ### 面向对象三大特征：
 1. 封装
 2. 多态 (js中没有多态)
 3. 继承
 
 ### 面向对象封装思路：
 * 将一些相同业务逻辑代码抽离出来,封装到一个父对象函数模型里,那么最终就可以让各个模块的子对象函数模型通过prototype继承父对象即可
 
### 函数重写 
* 对一个父对象已有的方法，在子对象里又拉出来写，这就是函数的重写(override)

### `try-catch-finally`异常检测语法:
```js
	 try{
	        // try里放主要的代码块,就是我们平常所写的正常代码
	    }catch(error){
	        // 如果try里代码出现了bug,则try里其余的代码不再运行,会立即跳转到catch块里的代码开始执行
	        // catch块里的参数error是一个异常对象,收集了try里碰到的异常信息
	    }finally{
	        // 此块可写可不写,根据实际情况的业务逻辑来合理使用finally,这个快的意思表示,不管代码在上边
	        // 运行了try还是catch,最终都会执行finally块
	    }
```
* 注意：
- 无论是`try`还是`catch`里的代码哪个执行，即便是有`return`，但是`finally`在这个语法体系里是被 强制执行的，所以如果`finally`里有`return`，则最终函数的结果是以最后一个`finally`里的`return`为结果的

### 正则表达式
```js
		//第一种写法
	  var regex = new RegExp(正则表达式,正则匹配规则)
	  //第二种写法:
	   var regex = / /
	   //g:全局匹配,i忽略大小写匹配,m忽略换行匹配
	   //正则表达式的方法 char() 方法 exec()方法
	   //通过正则对象`test()`方法校验输入的值是否OK
```

### 字符串`API`
- `charAt:`作用根据索引找到字符串里某个单字符,接受一个number参数,返回找到的那个字符串,如果索引找不到这个字,则返回一个空字符
- `concat:`作用字符串拼接方法,比+拼接的效率要高,参数时一个要拼接的字符串,返回一个拼接后的新字符串,
区别: +号拼接的字符串会在内存里留下来上一次拼接前的旧字符串变量
- `concat`方法在拼接时,其实只是对内存里的一个字符串进行操作,不会遗留旧字符串
- `indexOf:`根据一个字符串参数,查找这个字符串在原字符串里第一次出现的索引位置,返回结果是字符串在原字符串里的索引位置,如果要找的字符串在原字符串里没有,则返回-1; 还有第二个参数意思是从当前字符串的某个索引开始找第一个参数出现的索引
- `lastIndexOf:`根据参数字符串在原字符串中最后一次出现的索引位置,从头开始查的,如果没找到依然返回-1;
- `match:`根据一个字符串结果匹配原字符串里是否出现这个要匹配的字符串,可以是正则表达式,返回一个数组结果,在数组最终显示所有匹配信息,匹配结果字符串有以下信息: 开头几个值是match方法的参数在原字符串里匹配到的值,index值表示在原字符串中匹配的值得索引位置,input值表示原字符串就是调用match方法的字符串值,groups表示匹配,这个值在正则里面有效,所以这个方法一般搭配正则表达式来用
- `replace:`可以指定原字符串里的某段字符串根据replace方法进行替换,第一个参数时原字符串里的某段字符串,第二个参数是要替换的新字符串,第一个参数也可以是一个正则表达式,当是正则时,表示正则替换,第二个参数可以是一个回调函数.
- `search:` 搜索参数字符串或正则表达式在原字符串出现的索引位置,返回一个索引值,只会按正则把匹配到第一个结果所在索引返回,g无效
- `slice:` 截取字符串,可以传负值,倒着截取
- `split:` 根据一个字符串值,对原数组进行分割,将分割后每段字符串结果放入到一个数组里
- `substr` 截取字符串
- `substring` 截取字符串 (此方法实际开发用的比较多) 两个参数 第一个参数表示从某个索引开始截取,第二个参数表示截取结束的索引位置,截取时包含开头位置的索引字符,不包含结束索引的字符
- `trim` 表示将字符串两边的空格去掉
- `trimStrart` 表示将字符串开头的空格去掉
- `trimEnd` 表示将字符串结束的空格去掉
- `startsWith` 表示字符串开头匹配,如果匹配则返回true,否则返回false
- `endWith` 表示字符串结束匹配,如果匹配则返回true,否则返回false

### 数组`API`
- `toLowerCase` 转小写
- `toUpperCase` 转大写
- `join:` 作用就是根据一个表示字符串将数组里的每个部分连接起来转换成一个新的字符串并返回
- `reverse:` 作用就是将数组里的每个值进行反转
- `concat:` 作用字符串或数组拼接返回一个新数组或字符串
- `shift` 删除数组里的第一个元素,返回被删除的元素
- `pop` 删除最后一个元素,返回被删除的元素◊
- `unshift` 往数组的开头第一个索引位置加入一个新元素 返回新数组的新长度
- `push` 往数组的开头最后一个索引位置加入一个新元素 返回新数组的新长度
- `slice` 根据开始和结束索引截取一个数组,并返回截取一个新数组,包含截取部分,包含开头索引值,不包含结束索引值,支持负数,注意: 截取数组后不影响原数组长度,原数组的值也没影响
- `splice` 删除数组中一段数据,会改变原数组长度和原数组数据,此方法第一个参数是从哪个索引开始删,第二个参数时删除的个数,第三个参数到第N个参数的作用是往被删除的原数组里的那段数据放一段新数组进去,返回值将删除的一段数据放到一个新数组并返回,
	作用1: 删除数组里一串数据;
	作用2: 替换一个数组里数据;
- `delete` 可以删除数组或对象的某个元素 对象操作贼方便
	删除数字里元素时,通过数组的索引删除某个元素
	删除数组里一个元素时,是将当前索引元素值干掉,变成undefined,输出是empty,但不影响	数组的原始长度,相当于只是将那一项的值干为空值
	删除对象里某个元素时,通过某个元素的key来删除
	在删除对象某个值时贼方便,大多情况都是用在操作对象使用的,而对数组操作可以使用js提供pop`shift`splice来操作
	
### `Math`
- `Math.ceil()`上舍入
- `Math.floor()`下舍入
- `Math.round()`四舍五入
- `Math.abs()`求绝对值
- `Math.PI()`返回圆周率
- `Math.random()`获取0-1随机数
	- `Math.random()*(max-min)+min`获取min到max之间的任意随机数
	
### `Date`
- `date.getFullYear()` 获取年
- `date.getMonth()` 获取月,老外的每年的第一个月就是12月
- `date.getDate()` 获取日
- `date.getDay()` 获取星期
- `date.getHours()` 获取小时
- `date.getMinutes()` 获取分钟
- `date.getSeconds()` 获取秒
- `date.getTime()` 获取到1970-1-1的毫秒数
- `date.now()` 获得当前时间距离1970-1-1的毫秒差时间戳

### Object
- `Object.create()` create方法接受一个参数,参数可以是一个已有的对象,如果新对象,则传null ,第二参数可写可不写
- `Object.assing()` 深拷贝将一个对象复制给另外一个对象,第一个参数表示当前变量的原始数据,第二个参数表示要把某个数据复制到第一个参数里
- `Object.assing()` 只会对第一层数据做复制,但是深度的子对象和子数组数据并未做复制操作,而是直接赋值操作,所以Object.assing() 并不能成为深拷贝方法.Object.assing()兼容性有问题,同时又不能深拷贝.
- `Object.keys()` 可以获取一个对象里所有的key
- `Object.values()` 可以获取一个对象里的所有value值
- `Object.defineProperty()` 在一个对象里动态定义属性的操作方法,,三个参数必须填
	- 参数1: 要操作的对象
	- 参数2: 要添加的新属性名字,字符串值
	- 参数3: 属性的约束定义规则, 就是刚才讲过writable(是否可以重写),value(初始值),set(属性设置值),get(获取属性值),
		- `configurable`(是否可以被删除) 这个配置项的作用是管理当前通过definePrioerty添加的属性的是否可以被delete删除,默认值是false,表示不能被delete删除
		- `enumerable`(是否可以被循环) 这个配置是管理definePrioerty定义的属性是否可以在obj的循环时被循环出来,默认值是false,表示不可以被循环输出此属性,也就是说,此属性不在循环列表里,循环无法获得此属性如果是ture就可以正常循环


### 高阶函数
* 从设计模式角度,也成称为装饰设计者模式,本质就是利用回调函数,来将用户的操作行为独立的封装传递
* 高阶函数的核心思路，就是把多个封装函数中，相同的业务代码抽出来，不同的业务代码交给回调函数来处理即可那么在这个里边，回调函数cb就是所谓装饰设计者，而封装的所谓的高阶函数，则是被装饰设计的那面墙

# `ECMAScript:`部分结束


### 小技巧：
* 在使用vs code时,使用某些js提供的资料时,看到智能提示里前边图标是紫色盒子时便是在使用的是一个方法(函数）
* 如果是蓝色盒子时,表示是一个属性
