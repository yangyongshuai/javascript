##### `CDN:` `<script src="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js"></script>`
##### `this`变量查找
1. `this`在哪个函数声明
2. 这个函数的调用的函数在哪里
3. 函数的前面有没有对象的名字,有就是它,没有就是`window`
	- 特殊情况:
	 1. `call`和`apply`(`this`指向第一个参数)
	 2. 箭头函数(内部`this`指向箭头函数所在作用域内的`this`)(里面的`this`指向外面的`this`)
	 3. `new`(`this`指向实例)
	 4. `bind`返回的函数在调用时`this`永远指向`bind`的第一个参数
	 
##### 变量查找
1. 先写变量所在的作用域链
2. 顺着这个作用域链逐层往上查找,查找变量声明(形参也算),找到停止查找(就近原则)
 
##### `Vue`
###### 指令
* `v-if`通过删除和添加元素显示和隐藏
	* `v-else-if`	
	* `v-else`
* `v-show`通过切换样式display来显示和隐藏
* `v-for` 循环 
* `v-model`  将表单元素输入的内容绑定为显示数据 
	* `lize` 修饰符 取代`input`事件改为`change`事件
	* `number` 输入字符串转为有效的数字
	* `trim` 输入首尾空格过滤
* `v-bind` 把属性值变成变量 缩写: `:`
* `v-on` 缩写：`@`
	- `stop`调用 `event.stopPropagation()`。
	- `prevent` - 调用 `event.preventDefault()`。
	- `capture` - 添加事件侦听器时使用 `capture` 模式。
	- `self` - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
	- `{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。
	- `native` - 监听组件根元素的原生事件。
	- `once` - 只触发一次回调。
	- `left - (2.2.0)` 只当点击鼠标左键时触发。
	- `right - (2.2.0)` 只当点击鼠标右键时触发。
	- `middle - (2.2.0)` 只当点击鼠标中键时触发。
	- `passive - (2.3.0)` 以 `{ passive: true }` 模式添加侦听器
	
* `v-cloak` 为了解决视图渲染时有一瞬间看见查找表达式{{}},[v-cloak] { display: none } 一起用时 这个指令可以隐藏未编译的 文本内容 标签直到实例准备完毕。
* `v-text` 更新部分的文本内容
* `v-html` 内容按普通 `HTML` 插入 - 不会作为 `Vue` 模板进行编译
* `v-pre` 跳过这个元素和它的子元素的编译过程。可以用来显示原始 文本内容 标签。跳过大量没有指令的节点会加快编译。
* `v-once`只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

###### 响应式实现条件
1. 视图要绑定数据
2. 这个数据必须有数据监听
###### 什么情况下数据视图不会改变
1. 数组 : 修改数组的元素而不是修改数组数据
2. 对象 : 修改一个本来不存在的属性
3. 字符串 : 所有修改字符串的方法都不会修改本身
###### 会修改数组本身的方法
- `push`,`pop`,`shift`,`unshift`,`splice`,`sort`,`reverse`

###### 对象属性有四个基本描述
1. `value`值		--> `value`
2. 是不是可以修改  --> `writable`
3. 是不是可以删除  --> `configurable`
4. 是不是可枚举  --> `enumerable` --> `for - in`循环是否可以遍历到的属性 --> `for in` 遍历的是对象原型链上所有可枚举的属性

###### 选项
 选项/数据
- `Vue`构造函数的实参是一个`json`对象,这个`json`对象的属性就是选项
- 功能差不多`watch`可以操作异步,`computed`不能操作异步
	* `watch` 监听数据在数据变化时做一些额外的事情(默认事情是视图更新)监听的数据可以写成函数的形式也可以写成对象的形式 
		* `handler`
		* `deep`: 设为`true`该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深,可以监听对象内所有嵌套属性
		* `immediate`设为`true` 该回调将会在侦听开始之后被立即调用
	* `computed` 如果一个数据依赖于别的数据计算得出,都可以写成计算属性
	<!-- 	第一种:
		数据名(){
			retyrn 计算属性的值
		},
		第二种:
		数据名:{
			get(){},
			set(){}
		} -->
###### `set`设置监听
* 局部方法(实例方法) `created`  通过实例来调用(访问)的方法 `$set`
* 静态方法 (全局): 通过构造函数(类)来调用的方法 `set`
###### 选项/生命周期钩子
* `created`
###### 选项/资源
* `filter`
	* 全局过滤器 `Vue.filter`
	* 局部过滤器 `filters`与`data`同级
###### 组件
 每个组件都是一个`Vue`实例,都可以拥有自己的`data`

1. 什么是组件
	* 
2. 为什么用组件 
	* 
3. 用组件遇到什么问题,怎么解决
	*

- `compoments`注册组件,  与`data`同级
	* `template` 
```html
	<div id="app">
		<组件名></组件名>
	<div>
```
```javascript
	new Vue({
		data:{
			el:"#app",
		},
		components:{
			"组件名":{
				template:`
					//公共html部分
					<div></div>
				`,
				data(){
					return
				}
			}
		}
	})
```
* 组件A写在组件B的template内,则组件A就是组件B的子组件
* 不管是数据还是函数,写在哪个组件的视图内,就是哪个组件的....

- `is`属性 可以给一般标签添加`is`属性来引入组件
###### 组件的数据共享
* `props` 子组件数据如果需要接受父组件的数据,则这个数据需要通过`props`声明,在子组件的自定义标签上做父传子的数据复制

###### `watch`的使用 
```js
	watch:{
		//要监视的属性名 和 方法名一致
		方法名(){新值,旧值}
	}
```
- 参数1:改变后的新值
- 参数2:改变前的旧值
###### 子组件传向父组件
1. 父组件需要一个函数A接受子组件数据
2. 子组件添加一个自定义事件B,让这个自定义事件B发生时,触发父组件的函数A
3. 子组件在某个时候触发自定义事件B,并且传入子组件数据

* `$on(事件名,事件句柄)` -->给当前组件绑定一个自定义事件
* `$emit(事件名,传递给句柄的值)` -->主动触发自己的某个事件
* `$parent`当前组件的父组件实例
* `$children`当前子组件的列表

###### 生命周期/钩子
1. 什么是生命周期
	- 就是在`vue`实例化的过程中的各个阶段触发的函数
2. 为什么需要用生命周期钩子函数
	- 可以在`Vue`实例化的过程中,正确的阶段做正确的事情
3. 使用`Vue`生命周期的遇到问题怎么解决
	- 什么时候用什么钩子函数?
		- 如果需要默认情况下修改数据,使用`created`
		- 如果需要默认情况下修改视图,使用`mounted`
* `beforeCreate` 此阶段 的主要作用是初始化`model`的基本操作,准备好`model`数据的创建,就是创建`model`的准备工作
* `created`最终根据上一步准备好的工作,完成`model`的初始化创建
* `beforeMount`
* `mounted`
* `beforeUpdate`
* `updated`
* `beforeDestroy`
* `destroyed`
####### 生命周期
1. `Vue`实例化创建阶段
	- 给数据添加数据监听(setter和getter)
		- `beforeCreate`(数据监听前)`created`(数据监听后)
			* `vue`添加了监听事件后
				1. 判断有没有`el`选项
					- 如果有,继续判断有没有`template`选项
					- 如果没有,判断有没有调用`vm.$mount(el)`方法,如果还没有就终止
				 
	- 生成虚拟节点和生成视图
		- `beforeMount`(挂载前)`mounted`(挂载后)
2. 	`Vue`实例运行阶段
	- 如果发生了视图更新
		-`beforeUpdate`(视图更新前) `updated`(视图更新后)
	- 如果实例被销毁
		- `beforeDestroy`(销毁前) `destroyed`(销毁后)
###### 虚拟节点
1. 什么是虚拟节点?
	- 虚拟节点就是一个`json`对象们其实就是对一个`html`模板的描述
- `Vue`会把`html`模板先转换成虚拟节点,当视图更新,先更新虚拟节点,然后通过虚拟节点的前后变化,最后更新真实节点(`DOM`操作完成)

###### `watch`和 `updated`的区别
1. `watch`是数据更新时触发
2. `updated`是在视图更新后触发

###### 什么时候用`nextTick`
- 某次数据变化导致视图变化,如果你想知道这次视图变化的某些结果,就一定用`nextTick`
###### `keep-alive` 抽象组件  缓存
- 页面渲染后不会出现在页面上 ->用于缓存组件,动态组件在切换时,使用了缓存则不会重复的创建和销毁,可以保留组件状态  
###### 动态组件特有的声明钩子
* 当一个动态组件被缓存时?如何知道组件发生了变化?
- `activated` ->当组件激活(缓存)时,
- `deactivated` ->当组件隐藏(切换)时触发

####### `mixins`
* 用于提取多个组件具有相同的选项部分,可以将这部分单独写成一个公共的对象然后在需要使用这些选项的组件内通过`mixins`引入相同的选项
####### `render`用来替代`template`选项,性能更好,写起来麻烦
```js
	render(h){
		return h(标签名,{属性},{子节点列表})
	}
```

###### 插槽  用于内容分发
 * `<slot></slot>` -> 插槽 -> 用于将组件默认的内容进行分发到相应的位置

###### `directive`自定义指令

###### `vuex` 状态管理器 
* `Vuex.Store`
	- `store`写在 那里
* 完整的`vuex`共享数据流程

###### `Vue Router` 钩子守卫
* 局部守卫 参数都是(to, from, next)
- `beforeRouteEnter` 只触发一次 非动态路由使用 用于路由跳转拦截 不！能！获取组件实例`this`因为当守卫执行前，组件实例还没被创建,你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数
- `beforeRouteUpdate` 动态路由中能触发 ,监听动态路由的路由切换
- `beforeRouteLeave` 不触发 非动态路由使用 用于路由跳转拦截
* 路由独享守卫
- `beforeEnter`路由独享守卫 这个守卫是直接配置在路由规则数据里的守卫
* 全局路由守卫
- `beforeEach(to,from,next)=>{}` 全局路由前置守卫 参数是一个回调函数 
	- to 路由跳转目标路径的对象数据
	- from 表示路由从哪里开始跳转的对象数据
	- next 是管理是否放行
- `afterEach` 全局后置守卫
- `beforeResolve` 全局解析守卫
####### 首页默认跳转配置
```js
	//首页默认跳转配置   建议放在最前面
	path:'/',
	redirect:{
	 name:要跳转的组件名
	}
	// 404配置   放在最后面
	{
		path:'*',
		component:组件名称
	}
```
###### `$router`
###### `this.$router.replace/this.$router.push`的区别
* `push`会产生一个`history`记录,有历史记忆功能
* `replace`方法只是对当前路径做了一个字符串替换,没有`history`记忆功能无法返回上一页
	- `$router.go` 返回上一页
	- `$router.goBack`
	- `$router.goForward`
###### `axiso` 
```js
	Axios.get(请求路径)
	//请求成功结果
	.then(名称=>{
		console.log(名称)
	})
	//请求失败调用
	.catch(err => console.log(err))
	//get请求发送数据  params
	Axios.get(请求路径,{params:{发送的内容}})
	//请求成功结果
	.then(名称=>{
		console.log(名称)
	})
	//请求失败调用
	.catch(err => console.log(err))
```
###### `token`


* 苹果电脑前加`sudo`
1. 安装`node-js`  查看版本 `node -v`
2. `npm install -g cnpm --registry=https://registry.npm.taobao.org` 改成淘宝镜像源  查看`cnpm -v`
3. `cnpm install vue-cli -g` 安装脚手架 查看`vue -V`
- `vue init webpack my-project`把配置文件安装到创建一个`my-project`文件夹里
- `cnpm install` 安装配置文件夹`node_modules`
- `npm run dev`  运行网页
* 
- 安装其他东西  cnpm install 安装的东西 --save
	- 例子: `cnpm install vuex --save`
- 指定版本号安装 cnpm install 安装的东西 @版本号 --save
	- 例子: `cnpm install vuex @^3.1.2`

* 安装全局`webpack`
- 苹果安装:`sudo cnpm i webpack-cli webpack -g` 
- `window`安装:`npm i webpack-cli webpack -g`
- `i`是`install`简写 `g`是`global` 简写
### `npm`初始化包资源管理清单
- `npm init -y`初始化一个包资源管理清单 -y就是--yes的简写 会有一个`json`文件
```json
	{
	  "name": "project-1",  //项目名称
	  "version": "1.0.0",   //当前项目的版本号  (依据公司规定)
	  "description": "",	//项目的描述信息  (领导操心的事情)
	  "main": "index.js",	//项目主入口文件  (可以直接删除掉,后面会依据webpack来决定)
	  "scripts": { //在当前包资源管理空间里    配置指令 
	    "test": "echo \"Error: no test specified\" && exit 1",
		"src":"md src"  //配置自己的指令 这个是创建一个文件夹 运行 npm run 自定义指令名称
	  },
	  "keywords": [], // 项目里面关键词使用   直接删除没什么用
	  "author": "",		// 作者
	  "license": "ISC"   //许可 
		//### 管理包资源清单 
		//例子	npm i jquery -S    使用-S安装,会创建到dependencies选项里
		"dependencies": {		//dependencies 生产依赖选项包  一般都是在开发时代码里要用到的包 就是src目录里考法项目时要用的包  -S是--save的简写
		  "jquery": "^3.4.1"
		},
		//例子: npm i jquery -D    使用-D安装 会自动devDependencies选项,
		"devDependencies": {	//devDependencies 一般都是将跟代码无关,可是又跟生产有关的一些依赖包,装在这个选项里来保存包资料信息 这个选项的行话叫生产依赖选项
		  "jquery": "^3.4.1"
		}
	}
	总结: //跟实际代码开发有关的,装-S,跟构建解析有关的包都装-D  -D是辅助 -S开发时的一些功能包
```
* `npm`卸载包:`npm uninstall`
- 例子:`npm uninstall webpack -g`

### 全局安装`yarn`: `npm i yarn -g`
- 注意: 安装全局包时必须要用`npm`来装, 千万别用`yarn`
- 用npm安装完yarn后,yarn的默认包下载路径也是国外站点,需要执行下边指令来修改为淘宝镜像站点:
	yarn config set registry https://registry.npm.taobao.org
- 查看yarn的配置信息指令: yarn config list
### `yarn`的具体指令使用
* 初始化包资源管理清单
- `yarn init -y`
```json
{
  "name": "demo",
  "version": "1.0.0",
  "license": "MIT"
}
```
* 运行自定义指令: yarn run 自定义指令名
* 安装包指令: 例子: yarn add jquery -S 或 -D
* 根据packjson.js来安装包: yarn install 
- webpack构建工具的使用：   
	- 首先在项目的根目录里创建一个`“webpack.config.js”`webpack配置文件

### 安装 `less`
* `style-loader`
* `css-loader`
* `less`
* `less-loader`
* `yarn add less less-loader -D`
###### 脚手架项目环境搭建
* `src`
	- `assets` 放置一些全局静态文件资源
	- `components` 主要放置组件的目录
	- `config` 主要放置项目的配置文件目录 以可配置为荣,以硬编码为耻
	- `services` 放置一些跟项目业务逻辑处理有关的JS代码
	- `main.js` 程序主入口文件

##### 打包
	- npm run build


### `React`
```js
	//ReacDOM.render 把虚拟节点挂载到页面上生成新视图
	ReacDOM.render(el,document.getElementById('app'));
```
#### `bable` 这个插件是用来将字符串模板编译成虚拟节点 相当于(自动用`React.createElement`进行转换虚拟节点)

### `JSX`注释:
- 需要把注释写在花括号里
- 需要使用/* */的注释  
- `clrl+shift+?` 快速注释
```js
	{/*
		<span></span>
	 */}
```

### 列表渲染的条件
- {}内必须是一个数组
- 数组的元素必须是虚拟节点 
	* 如果数据不包含虚拟节点,需要通过map转换成虚拟节点的数组 再放入视图内 

### `react` 的组件写法
* `react`的组件模板必须通过函数返回 return返回
* 组件名字首字母必须是大写 
* 引入组件需要写自定义标签 标签名就是组件名字
1.函数组件
	- 一般用于显示不更新状态的组件
2.类组件
	- 使用关键字class
	- constructor 类的私有属性 内部的this指向实例
	- 实例化时也需要new
	- 类型时函数
	
